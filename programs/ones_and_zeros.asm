;
;DCPU-16 ASM Generated by LCC 4.2 (dcpu16-lcc v0.1)
;
JSR _global_main
:_crash
SET PC, _crash
:_global_main
SET PUSH, 0  ;making room on stack for locals
SET I, J
SET J, SP    ;set new frame pointer
SET PUSH, I  ;save previous frame pointer
SET PC, _L3
:_L2
SET Z, [J]
SET A, Z
AND A, 1
JSR _global_printf
ADD [J], 1
:_L3
SET PC, _L2
:_L1
SET J, POP   ;restore previous frame pointer
SET EX, POP  ;popping locals and register arguments from stack
SET PC, POP
:_scratch0
DAT 0
:_scratch1
DAT 0
:_scratch2
DAT 0
:_scratch3
DAT 0
:_scratch4
DAT 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
;
;dcpulib.dasm
;
:__dispptr
DAT 0x8000
:__dispoffset
DAT 0x8000
:__dispoffset_end
DAT 0x817F
:__isprintf
DAT 0
:__dispinit_flag
DAT 0
:__dispinit
SET PUSH, A 
SET PUSH, B
SET PUSH, C
SET PUSH, X
SET PUSH, Y
SET PUSH, Z
SET PUSH, I
SET PUSH, J
HWN Z
SET I, 0xFFFF
:__dispinit_loop
STI EX, EX
IFG I, Z
SET PC, __dispinit_done
HWQ I
IFN A, 0xF615
SET PC, __dispinit_loop
IFN B, 0x7349
SET PC, __dispinit_loop
SET A, 0
SET B, [__dispoffset]
HWI I
SET [__dispinit_flag], 1
:__dispinit_done
SET J, POP
SET I, POP
SET Z, POP
SET Y, POP
SET X, POP
SET C, POP
SET B, POP
SET A, POP
SET PC, POP
;
;extern int printf( const char*, ... );
;
:_global_printf
SET [_scratch0], POP
SET PUSH, C
SET PUSH, B
SET [_scratch1], Z
SET Z, SP
SET PUSH, X
SET PUSH, Y
SET X, 0
SET Y, A
:__printf_loop
IFE [Y], 0
SET PC, __printf_done
IFN [Y], 37 ;%
SET PC, __printf_putc
IFE [1+Y], 37 ;%
SET PC, __printf_putpct
IFE [1+Y], 99 ;c
SET PC, __printf_putc2
IFE [1+Y], 115 ;s
SET PC, __printf_puts
IFE [1+Y], 100 ;d
SET PC, __printf_putd
IFE [1+Y], 117 ;u
SET PC, __printf_putu
IFE [1+Y], 102 ;f
SET PC, __printf_putf
IFE [1+Y], 112 ;p
SET PC, __printf_putx
IFE [1+Y], 120 ;x
SET PC, __printf_putx
SET PC, __printf_putc
:__printf_putpct
ADD Y, 1
IFE [Y], 0
SET PC, __printf_done
SET PC, __printf_putc
:__printf_putc2
ADD Y, 2
SET A, [Z]
BOR A, 0xF000
ADD Z, 1
JSR _global_putchar
ADD X, 1
SET PC, __printf_loop
:__printf_puts
ADD Y, 2
SET A, [Z]
ADD Z, 1
SET [__isprintf], 1
JSR _global_puts
ADD X, A
SET PC, __printf_loop
:__printf_putd
ADD Y, 2
SET A, [Z]
SET B, _scratch4
SET C, 10
ADD Z, 1
JSR _global_itoa
SET A, _scratch4
SET [__isprintf], 1
JSR _global_puts
ADD X, A
SET PC, __printf_loop
:__printf_putu
ADD Y, 2
SET A, [Z]
SET B, _scratch4
SET C, 10
ADD Z, 1
JSR _global_utoa
SET A, _scratch4
SET [__isprintf], 1
JSR _global_puts
ADD X, A
SET PC, __printf_loop
:__printf_putf
ADD Y, 2
SET A, [Z]
SET B, _scratch4
ADD Z, 1
JSR _global_ftoa
SET A, _scratch4
SET [__isprintf], 1
JSR _global_puts
ADD X, A
SET PC, __printf_loop
:__printf_putx
ADD Y, 2
SET A, [Z]
SET B, _scratch4
SET C, 16
ADD Z, 1
JSR _global_utoa
SET A, _scratch4
SET [__isprintf], 1
JSR _global_puts
ADD X, A
SET PC, __printf_loop
:__printf_putc
SET A, [Y]
BOR A, 0xF000
JSR _global_putchar
ADD X, 1
ADD Y, 1
SET PC, __printf_loop
:__printf_done
SET A, X
SET Z, [_scratch1]
SET Y, POP
SET X, POP
SET EX, POP
SET EX, POP
SET PC, [_scratch0]
;
;extern unsigned putchar( unsigned );
;
:_global_putchar
IFE [__dispinit_flag], 0
JSR __dispinit
SET B, [__dispptr]
SET C, A
AND C, 0x007F
IFN C, 0x000A
SET PC, __putchar_cont
JSR __newline
SET [__dispptr], B
SET PC, POP
:__putchar_cont
SET [B], A
ADD B, 1
IFG B, [__dispoffset_end]
SET B, [__dispoffset]
SET [__dispptr], B
SET PC, POP
;
;extern int puts( const char* );
;
:_global_puts
IFE [__dispinit_flag], 0
JSR __dispinit
SET B, [__dispptr]
SET C, 0
:__puts_loop
IFN [A], 0x000A ;'\n'
SET PC, __puts_std
JSR __newline
SET PC, __puts_cont
ADD A, 1
:__puts_std
SET [B], [A]
BOR [B], 0xF000
ADD B, 1
:__puts_cont
IFG B, [__dispoffset_end]
SET B, [__dispoffset]
ADD A, 1
ADD C, 1
IFN [A], 0
SET PC, __puts_loop
:__puts_done
IFN [__isprintf], 0
SET PC, __puts_cont2
JSR __newline               ;newline at the end
ADD C, 1
:__puts_cont2
SET [__isprintf], 0
SET A, C
SET [__dispptr], B
SET PC, POP
:__newline
SET I, B
MOD I, 0x0020
IFE I, 0
SET PC, __newline_done
SET [B], 0
ADD B, 1
SET PC, __newline
:__newline_done
IFG B, [__dispoffset_end]
SET B, [__dispoffset]
SET PC, POP
;
;extern char* itoa( int, char*, int );
;
:_global_itoa
SET PUSH, B
IFG 0x7FFE, A
SET PC, __itoa_cont
SET [B], 45
ADD B, 1
SET I, 0
SUB I, A
SET A, I
:__itoa_cont
JSR _global_utoa
SET A, POP
SET PC, POP
;
;extern char* ftoa( float, char* );
;
:_global_ftoa
SET C, 10
SET PUSH, B
SET PUSH, A
IFG 0x7FFE, A
SET PC, __ftoa_cont
SET [B], 45
ADD B, 1
SET I, 0
SUB I, A
SET A, I
SET PEEK, A
:__ftoa_cont
SHR A, 8
JSR _global_utoa
SET A, POP
AND A, 0x00FF
IFE A, 0
SET PC, __ftoa_done
SET [B], 46
ADD B, 1
MUL A, 100
DIV A, 256
IFG EX, 128
ADD A, 1
JSR _global_utoa
:__ftoa_done
SET A, POP
SET PC, POP
;
;extern char* utoa( unsigned, char*, int );
;
:_global_utoa
IFG 2, C
SET C, 10
IFG C, 16
SET C, 10
SET PUSH, X
SET PUSH, Z
SET X, B
:__itoa_loop
SET I, A
MOD I, C
ADD I, 48
IFG I, 57
ADD I, 39
SET [B], I
ADD B, 1
DIV A, C
IFN A, 0
SET PC, __itoa_loop
SET PUSH, B
SET [B], 0
SUB B, 1
SET A, X
SET Z, B
SUB Z, X
SHR Z, 1
ADD Z, 1
ADD Z, X
:__itoa_loop2
SET C, [A]
SET [A], [B]
SET [B], C
ADD A, 1
SUB B, 1
IFN A, Z
SET PC, __itoa_loop2
SET A, X
SET B, POP
SET Z, POP
SET X, POP
SET PC, POP
;
;extern unsigned* getdispcur();
;
:_global_getdispcur
SET A, [__dispptr]
SUB A, [__dispoffset]
SET PC, POP
;
;extern unsigned* setdispcur(unsigned*);
;
:_global_setdispcur
IFG A, 0x017F
SET A, 0x017F
ADD A, [__dispoffset]
SET [__dispptr], A
SET PC, POP
;
; extern void* malloc(unsigned)
;
:_global_malloc
IFE 0, [__heapinit_flag]
JSR __heapinit
SET B, __heaphead
IFE B, 0
SET PC, __malloc_error
SET I, A            ;I = requested size
SET A, [B]          ;A = pointer to current block
:__malloc_loop
IFG [1+A], I
SET PC, __malloc_doit
IFE [1+A], I
SET PC, __malloc_doit
SET B, A            ;B = pointer to previous block (or head)
SET A, [A]
IFE A, 0
SET PC, __malloc_error
SET PC, __malloc_loop
:__malloc_doit
SET C, A
ADD C, 2
ADD C, [1+A]        ;C = pointer to current block's footer
SET PUSH, [1+A]
SUB PEEK, I
IFG 8, PEEK
SET PC, __malloc_doit2
SUB PEEK, 4         ;PEEK = new block size
SET [C], PEEK       ;store new block's size in footer
SET [1+C], A        ;set new block's prev -> current block
SUB C, PEEK
SUB C, 4            ;update C (current block shrank)
SET [1+A], I        ;store current block's size in header
SET [C], I          ;store current block's size in footer
SET [2+C], [A]      ;set new block's next
SET [3+C], PEEK     ;store new block's size in header
SET [A], C
ADD [A], 2          ;set current block's next -> new block
:__malloc_doit2
SET I, [A]
SET [A], 1          ;flag current block as used
SET [1+C], 1        ;flag current block as used
SET [B], I          ;set previous block's next = current block's next
IFE I, 0
SET PC, __malloc_doit3
ADD I, [1+I]
SET [3+I], B        ;set reverse link
:__malloc_doit3
ADD A, 2
SET EX, POP
SET PC, __malloc_done
:__malloc_error
SET A, 0
:__malloc_done
SET PC, POP
;
; extern void free(void*)
;
:_global_free
IFE 0, [__heapinit_flag]
SET PC, POP
IFG A, 0x8000
SET PC, POP
IFG __heaphead, A
SET PC, POP
SET C, A
SUB A, 4                ;A = pointer to left block's footer
SET B, [3+A]            ;B = current block size
ADD C, B                ;C = pointer to current block's footer
IFN B, [C]              ;sanity checks
SET PC, POP             ;
IFN [2+A], 1            ;
SET PC, POP             ;
IFN [1+C], 1            ;
SET PC, POP             ;
SET I, [__heaphead]
SET [2+A], I            ;current->next = *head
SET [1+C], __heaphead   ;current->prev = head
IFE I, 0
SET PC, __free_cont
ADD I, [1+I]
ADD I, 3
SET [I], A
ADD [I], 2              ;current->next->prev = current
:__free_cont
SET [__heaphead], A
ADD [__heaphead], 2
:__free_mergeright
IFE C, 0x7FFE           ;no right block
SET PC, __free_mergeleft
IFE [2+C], 1            ;right block used
SET PC, __free_mergeleft
SET PUSH, X
SET PUSH, [2+C]         ;push(right->next)
SET I, C                ;I = right->prev
ADD I, [3+C]            ;
ADD I, 5                ;
SET X, [I]              ;X = *(right->prev)
SET [X], PEEK           ;right->prev->next = right->next
SET X, POP              ;X = *(right->next)
IFE X, 0
SET PC, __free_mergeright_cont
ADD X, [1+X]            ;X = right->next->prev
ADD X, 3                ;
SET [X], [I]            ;right->next->prev = right->prev
:__free_mergeright_cont
SET X, B                ;X = new block size
ADD X, [3+C]            ;
ADD X, 4                ;
SET [3+A], X            ;store new size in header
SET [I], __heaphead     ;current->prev = head
SUB I, 1                
SET [I], X              ;store new size in footer
SET B, X                ;update B/C for mergeleft
SET C, I                ;
SET X, POP
:__free_mergeleft
IFG __heaphead, A       ;no left block
SET PC, POP
IFE [1+A], 1            ;left block is not free
SET PC, POP
SET PUSH, X
SET X, A                ;X = left->next
SUB X, [A]              ;
SUB X, 2                ;
SET PUSH, X             ;push(left->next)
SET X, [X]              ;X = *(left->next)
SET I, [1+A]            ;I = *(left->prev)
SET [I], X              ;left->prev->next = left->next
IFE X, 0
SET PC, __free_mergeleft_cont
ADD X, [1+I]            ;X = left->next->prev
ADD X, 3                ;
SET [X], [1+A]          ;left->next->prev = left->prev
:__free_mergeleft_cont
SET X, B                ;X = new block size
ADD X, [A]              ;
ADD X, 4                ;
SET I, POP              ;I = left->next
SET [1+I], X            ;store new size in header
SET [C], X              ;store new size in footer
SET [I], [2+A]          ;copy current->next to new header
SET [__heaphead], I     ;point head to new header
SET X, POP
SET PC, POP
:__heapinit_flag
DAT 0
:__heapinit2
SET [__heaphead], I
SET [I], 0
SET [1+I], 0x8000
SUB [1+I], I
SUB [1+I], 4
SET [0x7FFE], [1+I]
SET [0x7FFF], __heaphead
SET [__heapinit_flag], 1
SET PC, POP
:__heapinit
SET I, PC
ADD I, 4
SET PC, __heapinit2
:__heaphead
DAT 0                                                                                                                         
:__heap1stblk
DAT 0
:__heap1stsize
DAT 0                                                                                                                 